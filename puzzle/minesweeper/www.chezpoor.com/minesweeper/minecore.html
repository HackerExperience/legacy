<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
	<meta name="author" content="Shep Poor" />
	<meta name="description" content="JavaScript Minesweeper" />

	<title>MineSweeper</title>
	
	<style type="text/css">
		.menu_margin { margin-bottom: 5px; } /* force margins around the menu title */
		.menu_title { font-family: helvetica; font-size: 12px; }
		.menu_dropdown { position:absolute; visibility:hidden; width:150px; top:30px; z-index:5; }
		a { text-decoration: none; cursor: default; } /* Remove underline from menus */
		a:link, a:visited, a:active { color: #000; }
		a:hover { color: #00C; }
		.menu_item { font-family: helvetica; font-size: 12px; }
		.menu_divider { font-family: helvetica; font-size: 2px; }
		.focus_box { width: 40; position: absolute; z-index: 2; top: 10; left: -200; }
		.pause { text-align: center; visibility:hidden; color: #fff; background-color:#000; border-style: solid; position:absolute; height: 134px; width: 134px; left:15px; top:72px; z-index:2; }
		.disarm { opacity: 0.9; text-align: center; visibility:hidden; background-color:#DDAA77; border-style: solid; position:absolute; height: 134px; width: 134px; left:15px; top:72px; z-index:2; }
		.disarmCountdown { font-family:Courier; font-weight: bold; font-size:20pt; }
	</style>
</head>

<body bgcolor="#C0C0C0" onunload="gameClose()" onclick="clickInBrowser()">

<script type="text/javascript" src="http://www.chezpoor.com/minesweeper/minecookie.js"></script>


<!-- Create the menus 
     Uses DHTML layers, with a table around them.  Note the use of 
     OnClick as the handler.  See the javascript above. -->

<!-- Game menu -->
<div id="divMenuGame" class="menu_dropdown" style="left:10px;">
  <table border="1" bgcolor="#C0C0C0"><tr><td class="menu_item" nowrap="nowrap">
    <img src="http://www.chezpoor.com/minesweeper/images/notchecked.gif" width="10" height="10" alt="" name="imNew"          />&nbsp;<a onclick="return menuItemClick('New')">New &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F2</a><br />
    <img src="http://www.chezpoor.com/minesweeper/images/notchecked.gif" width="10" height="10" alt="" name="imPause"        />&nbsp;<a onclick="menuItemClick('Pause')"     >Pause&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P</a><br />
    <hr />
    <img src="http://www.chezpoor.com/minesweeper/images/notchecked.gif" width="10" height="10" alt="" name="imBeginner"     />&nbsp;<a onclick="menuItemClick('Beginner')"     >Beginner</a><br />
    <img src="http://www.chezpoor.com/minesweeper/images/notchecked.gif" width="10" height="10" alt="" name="imIntermediate" />&nbsp;<a onclick="menuItemClick('Intermediate')" >Intermediate</a><br />
    <img src="http://www.chezpoor.com/minesweeper/images/notchecked.gif" width="10" height="10" alt="" name="imExpert"       />&nbsp;<a onclick="menuItemClick('Expert')"       >Expert</a><br />
    <img src="http://www.chezpoor.com/minesweeper/images/notchecked.gif" width="10" height="10" alt="" name="imCustom"       />&nbsp;<a onclick="menuItemClick('Custom')"       >Custom</a><br />
    <hr />
    <img src="http://www.chezpoor.com/minesweeper/images/notchecked.gif" width="10" height="10" alt=""                       />&nbsp;<a onclick="return menuItemClick('Personal')" >Personal&nbsp;Best</a><br />
    <img src="http://www.chezpoor.com/minesweeper/images/notchecked.gif" width="10" height="10" alt=""                       />&nbsp;<a onclick="return menuItemClick('World')"    >World&nbsp;Champs</a>&nbsp;<br />
    <hr />
    <img src="http://www.chezpoor.com/minesweeper/images/notchecked.gif" width="10" height="10" alt="" name="imExit"         />&nbsp;<a onclick="return menuItemClick('Exit')"  >Exit</a><br />
  </td></tr></table>
</div>

<!-- Options menu -->
<div id="divMenuOpt" class="menu_dropdown" style="left:53px;">
  <table border="1" bgcolor="#C0C0C0"><tr><td class="menu_item" nowrap="nowrap">
    <img src="http://www.chezpoor.com/minesweeper/images/notchecked.gif" width="10" height="10" alt="" name="imZoomIn"   />&nbsp;<a onclick="return zoomIn()"  title="Zoom works on most modern browsers" >Zoom In</a><br />
    <img src="http://www.chezpoor.com/minesweeper/images/notchecked.gif" width="10" height="10" alt="" name="imZoomOut"  />&nbsp;<a onclick="return zoomOut()" title="Zoom works on most modern browsers" >Zoom Out</a><br />
    <hr />
    <a onclick="return menuItemClick('First')"     title="The first move will always open a useful series of squares" >                     <img src="http://www.chezpoor.com/minesweeper/images/checked.gif" alt=""    name="imFirst"    border="0" width="10" height="10" />&nbsp;Opening&nbsp;Move</a><br />
    <a onclick="return menuItemClick('Marks')"     title="Second left-click changes bomb marking to a question mark">                       <img src="http://www.chezpoor.com/minesweeper/images/checked.gif" alt=""   name="imMarks"     border="0" width="10" height="10" />&nbsp;Marks (?)</a><br />
    <a onclick="return menuItemClick('Area')"      title="Clicking on numbered/satisfied square will open all its neighbors">               <img src="http://www.chezpoor.com/minesweeper/images/checked.gif" alt=""   name="imUseMacro"  border="0" width="10" height="10" />&nbsp;Area Open</a><br />
    <a onclick="return menuItemClick('Remaining')" title="When 0 bombs are left unmarked, click the bomb counter 000 to open all remaining"><img src="http://www.chezpoor.com/minesweeper/images/checked.gif" alt=""   name="imRemaining" border="0" width="10" height="10" />&nbsp;Open&nbsp;Remaining</a>&nbsp;<br />
    <a onclick="return menuItemClick('Disarm')"    title="Give the option to undo the last move. Will not count as high scores game">       <img src="http://www.chezpoor.com/minesweeper/images/checked.gif" alt=""   name="imDisarm"    border="0" width="10" height="10" />&nbsp;Disarm&nbsp;(undo)</a>&nbsp;<br />
    <a onclick="return menuItemClick('Hints')"     title="Show a hint when pointing at a cell and pressing the letter H">                   <img src="http://www.chezpoor.com/minesweeper/images/checked.gif" alt=""   name="imHints"    border="0" width="10" height="10" />&nbsp;Hints&nbsp;(press H)</a>&nbsp;<br />
  </td></tr></table>
</div>

<!-- Help menu -->
<div id="divMenuHelp" class="menu_dropdown" style="left:110px;">
  <table border="1" bgcolor="#C0C0C0"><tr><td class="menu_item" nowrap="nowrap">
    &nbsp;<a onclick="return menuItemClick('Instructions')">Instructions</a><br />
    <hr />
    &nbsp;<a onclick="return menuItemClick('Technical')"   >Technical Notes</a>&nbsp;<br />
    &nbsp;<a onclick="return menuItemClick('Source')"      >Files &amp; Source</a><br />
    <hr />
    &nbsp;<a onclick="return menuItemClick('About')"       >About</a><br />
  </td></tr></table>
</div>

<!-- Undo / Disarm modal dialog -->
<div id="divDisarm" class="disarm">
    <p>Mine detonates in<br>
    <span class="disarmCountdown" id="detonateCountdown">3</span><br />
      <input type="button" onclick="disarmMine();" value="Disarm The Mine"><br>
      <input type="button" onclick="acceptFate();" value="Accept Your Fate">
    </p>
</div>

<!-- Pause modal dialog -->
<div id="divPause" class="pause">
    <p>PAUSED</p>
    <p><input type="button" onclick="doUnpause();" value="Resume"></p>
</div>


<script type="text/javascript">
// Use this in addition to the comment block because the w3c validator chokes on the Javascript decrement operator "--"
<!--

try{
	window.scrollbars.visible = false; }
catch (e) { }

// Return the WIDTH of the MineSweeper game window to be created.
// It calculates based on the actual width of the images which allows for zooming and skinning.
function calcWidth(maxX) {
   // Extra 22 is for window border (required).
   return ((maxX+1)*document.cellIm1_1.width+ 2*document.bordertl.width +22 +10) * zoomPower(); }

// Return the HEIGHT of the MineSweeper game window to be created.
function calcHeight(maxY) {
   // Extra 23 for borders, 16 for menu bar, 35 is for top/bottom margin.
   statusbarExtra = 16;
   try {
   	if (window.statusbar.visible) {
   		statusbarExtra = 28; }
   }
   catch (e) {}
   // 12 extra because Firefox defaults to not allowing toolbar to be suppressed, and doesn't report it properly! (can't check window.toolbar).
   // 2006-09-26 Added another 10 (so +22) because users are complaining.
   // 2007-12-28 IE sux and has a new top bar, so add another +23, so +45 total extra.
   // 2013-01-29 IE still sux. Floats link address. adding a bit more, now +64
   return ((maxY+1)*document.cellIm1_1.height +document.time1s.height +(document.bordertl.height*3) +23 +35 +16 +64 +statusbarExtra) * zoomPower(); } // }

//
// Variable and document setup stuff:
//

   // Read in the board dimensions cookies
   gameFormat = getCookie("gameFormat");

   // Set additional params based on cookies or size defaults.
   // Roll-your-own (custom)
   if (gameFormat == "Custom") {
      maxX = parseInt(getCookie("maxX"));
      maxY = parseInt(getCookie("maxY"));
      maxNumBombs = parseInt(getCookie("maxNumBombs")); }
   // Intermediate
   else { if (gameFormat == "Intermediate") {
      maxX = 15;
      maxY = 15;
      maxNumBombs = 40; }
   // Expert
   else { if (gameFormat == "Expert") {
      maxX = 30;
      maxY = 15;
      maxNumBombs = 99; }
   // Beginner (also the default)
   else { 
      maxX = 7;
      maxY = 7;
      maxNumBombs = 10;
      gameFormat = "Beginner"; } } }
      
   // This pre-calc just makes the next "if" easier to handle.
   maxLegalBombs = Math.round((maxX+1)*(maxY+1) / 2)  // Max 1/3 of all cells

   // Make sure all values are numbers and are within range
   if ((isNaN(maxX)) || (maxX<7) || (maxX>31) || (isNaN(maxY)) || (maxY<7) || (maxY>24) || (isNaN(maxNumBombs)) || (maxNumBombs<1) || (maxNumBombs>maxLegalBombs)) {
   //Not in range: Fancy alert screen
      alert("Minesweeper dimensions invalid:\n\tWidth: From 8 to 32\n\tHeight: from 8 to 24\n\tBoms: 1 to 1/3 of squares"); 
      maxX = 7;
      maxY = 7;
      maxNumBombs = 10;
      gameFormat = "Beginner"; }

   setCookie("gameFormat",gameFormat);

   // Read the other param vars set by the intro page
   // Note how the double negative will force missing to default to true
   useQuestionMarks = ! (getCookie("useQuestionMarks") == 'false');
   useMacroOpen = ! (getCookie("useMacroOpen") == 'false');
   useFirstClickUseful = ! (getCookie("useFirstClickUseful") == 'false');
   openRemaining = (getCookie("openRemaining") == 'true');
   allowDisarm = (getCookie("allowDisarm") == 'true');
   allowHints = ! (getCookie("allowHints") == 'false');

   
   // Set global constants   
   maxCells = (maxX+1)*(maxY+1)-1;       // Constant: # of cells on board
   topImages = 24;                        // 8 on game menu, 9 on opt menu, 3 bomb #s, smile face, 3 time #s
   maxStackHeight = 300;                 // For recursive cell opening stack
   smileMargin=((maxX+1)*16-(13*6+26))/2;// To center smile & right justify time

   // Global Arrays (created once)
   cellArray = new Array(maxCells);      // One per cell on the board
   for (l=0; l<=maxCells; l++) {
      cellArray[l]=new constructCell()}
   markedArray = new Array(maxStackHeight); // For recursive cell opening stack
   
   // Variables used & reset during play
   dead = false;                         // Hit a bomb?
   win = false;                          // All cells open?
   bombsFlagged = 0;                     // How many bombs marked so far?
   cellsOpen = 0;                        // How many cells open so far?
   markedCount = -1;                     // For recursive cell opening stack
   highestStackHeight = -1;              // For recursive cell opening stack
   pointingAtX = -1;                     // Current cell being pointed at.
   pointingAtY = -1;                     // Used for space bar bomb flagging
   numMoves = 0;                         // Count the number of clicks
   openRemainingUsed = false;            // Was openRemaining used by the player?
   allowDisarmUsed = false;              // Was allowDisarm (undo option) used?
   allowHintsUsed = false;               // Press "H" to display a hint
   lastClickOnMenu = false;              // Used to control smooth menu closing
   disarmed = 0;                         // Num of disarmed (undo) used
   hints = 0;                            // Num of hints used
   paused = false;

   // Vars for the clock time
   clockMoving  = false;                 // Is it moving?
   clockActive  = false;                 // Should it be moving?
   killLastClock= false;                 // To start new time w/ old still running
   clockCurrent = -1;                    // Current time

   // Undo/disarm clock variables
   fuseBurning = false;                   // did the user hit a bomb, waiting to see if they want to "undo"
   fuseRemaining = 0;                     // Time left to disarm (undo) hitting a bomb
   disarmX=0;
   disarmY=0;


   // preload images: all time/#bombs images, including the negative
   timeDigits = new Array(10);
   for (l=0; l <= 9; l++) {
      timeDigits[l] = new Image(23,13); 
      tstr = "images/time" + l + ".gif";
      timeDigits[l].src = tstr; }
   timeNeg = new Image(23,13);
   timeNeg.src = "images/time-.gif";
  
   // preload moves counter images
   movesDigits0 = new Image(23,13); 
   movesDigits0.src = "images/moves0.gif";

   // preload images: 9 open tiles (0..8)
   cellOpenIm = new Array(9);
   for (l=0; l<=8; l++) {
      cellOpenIm[l] = new Image(16,16);
      tstr = "images/open" + l + ".gif";
      cellOpenIm[l].src = tstr; }

   // preload images: 8 open tiles (1..8) (skips index of 0)
   cellShadowIm = new Array(9);
   for (l=0; l<=8; l++) {
      cellShadowIm[l] = new Image(16,16);
      tstr = "images/shadow" + l + ".gif";
      cellShadowIm[l].src = tstr; }

   // preload images: the many faces of bombs and bomb markers
   bombFlagged = new Image(16,16);
   bombFlagged.src = "images/bombflagged.gif";
   bombDisarmed = new Image(16,16);
   bombDisarmed.src = "images/bombdisarmed.gif";
   bombRevealed = new Image(16,16);
   bombRevealed.src = "images/bombrevealed.gif";
   bombMisFlagged = new Image(16,16);
   bombMisFlagged.src = "images/bombmisflagged.gif";
   bombDeath = new Image(16,16);
   bombDeath.src = "images/bombdeath.gif";
   bombQuestion = new Image(16,16);
   bombQuestion.src = "images/bombquestion.gif";
   bombShadow = new Image(16,16);
   bombShadow.src = "images/shadowbomb.gif";
   blankCell = new Image(16,16);
   blankCell.src = "images/blank.gif";

   // preload images: the 3 faces (can't use "oh" w/o mouseUp/Down methods)
   faceDead = new Image(26,26);
   faceDead.src = "images/facedead.gif";
   faceSmile = new Image(26,26);
   faceSmile.src = "images/facesmile.gif";
   faceWin = new Image(26,26);
   faceWin.src = "images/facewin.gif";
   faceWait = new Image(26,26);
   faceWait.src = "images/faceclock.gif";
   faceOoh = new Image(26,26);
   faceOoh.src = "images/faceooh.gif";
   facePirate = new Image(26,26);
   facePirate.src = "images/facepirate.gif";

   // preload images: two images used in the menus for check marks and place holders
   checked = new Image(10,10);
   checked.src = "images/checked.gif";
   notchecked = new Image(10,10);
   notchecked.src = "images/notchecked.gif";




// Creates the internal cells (as opposed to the image cells).  Called once
// per cell upon creation of the window (see above).
function constructCell() {
   this.isBomb = false;         // Is the cell a bomb?
   this.isExposed = false;      // Is it open?
   this.isFlagged = false;      // Does it have a bomb flag on it?
   this.isDisarmed = false;     // Disarm (undo) used after hitting the bomb?
   this.isQuestion = false;     // Question mark (if its used)
   this.isMarked = false;       // Used for recursive macro opening
   this.neighborBombs = 0; }    // # surrounding bombs.  Set for all cells.


// This turns the board layout into a base64 string for easy transport as a single param.
// The output string contains the dimensions (bytes 0 & 1) and the location of all bombs as bits,
// 6 cells per base64 byte.
// This fn is completely unnessary for this page but fun for some future ideas...
// Should be called at the end of firstClick() just in case the first click moved a bomb.
function boardToBase64() {
    var base64Vec="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var bits=0;         // builds up the 6 bits used to create the next base64 character
    var strResult="";
    for (var indx=0; indx<=maxCells; indx++) {
      // Every 6 cells, push the new base64 charcter into the result string.
      if ((indx > 0) && ((indx % 6) == 0)) {
        strResult += base64Vec.charAt(bits);
        bits = 0;
      }
      // Builds a byte from 1st bit up to the 6th bit.
      bits = bits | (cellArray[indx].isBomb * (1 << (indx%6)));  // Shifting is faster than Math.pow() for base 2 powers
    }
    // Prepend the board dimensions, and append the remaining bits.
    // The remaining bits may not be a full 6 bits, but any unused bits were initialized to 0 anyway.
    strResult = base64Vec.charAt(maxX) + base64Vec.charAt(maxY) + strResult + base64Vec.charAt(bits);
    return strResult;
}


// Load a board from a base64 vector.
// This function is not ready for use. (No board str validation, doesn't handle board size changes, etc).
function loadBoardBase64(thisBoard) {
    var base64Vec="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    // Although it reloads dimensions it doesn't change the board itself
    if ((maxX != base64Vec.indexOf(thisBoard.charAt(0))) || (maxY != base64Vec.indexOf(thisBoard.charAt(1)))) {
      maxX = base64Vec.indexOf(thisBoard.charAt(0));
      maxY = base64Vec.indexOf(thisBoard.charAt(0));
    }
    clearBoard();
    bombsFlagged = 0;
    cellsOpen = 0;
    hints = 0;
    disarmed = 0;
    clearBoardImages();
    // Clear the # of bombs, re-calc as we place the bombs
    maxNumBombs = 0;
    for (var indx=0; indx<=maxCells; indx++) {
        if ((base64Vec.indexOf(thisBoard.charAt(2+Math.floor(indx/6))) & (1 << (indx%6))) > 0) {
            placeBomb(indx % (maxX+1), Math.floor(indx / (maxX+1)));
            maxNumBombs++;
        }
    }
    updateNumBombs();
}

//
// General-purpose routines called from throughout the game
//


// Returns the index of the internal playing board cellArray at given
// x,y coords (on 0..n-1 scale).  Very useful fn.
function arrayIndexOf(x,y) {
   return x+y*(maxX+1); }


// Returns the index of the documents image pointing to cell at given
// x,y coords (on 0..n-1 scale).  Very useful fn.
// Notes: topImages are the 3 bomb digits, the face, & the 3 time digits.
//        Uses maxX+2 (not maxX+1) to include borderRight images.
function imageIndexOf(x,y) {
   return x+(y+2)*(maxX+3)+topImages+3; } // This is the simplified version
// return x+y*(maxX+2)+topImages+(maxX+1)*2+(y+1)+6; }


// Makes sure x,y coords are within the board.  Returns true or false.
function checkBounds(x,y) {
  return ((0<=x) && (x<=maxX) && (0<=y) && (y<=maxY)); }

// Saves the current pointing location of the mouse.  Called w/ onMouseOver
// for each cell.
function cursorHoldLoc(x,y) {
   pointingAtX = x;
   pointingAtY = y; 
   forceFocus(); }

// Clears the saved location.  Needed when user points outside the grid.
// Note: I check that I'm clearing the correct cell, just in case events
// occur out of order.
function cursorClearLoc(x,y) {
   if ((pointingAtX == x) && (pointingAtY == y)) {
      pointingAtX = -1;
      pointingAtY = -1; } }


// Complete the Win process. Save the cookies, and call the winning window.
function winShowWindow() {
   win = true;
   setCookie("gameTime",clockCurrent);
   setCookie("numMoves",numMoves);
   setCookie("openRemainingUsed",openRemainingUsed);
   setCookie("allowDisarmUsed",allowDisarmUsed);
   setCookie("allowHintsUsed",allowHintsUsed);
   if ((hints == 0) && (disarmed==0)) {
    document.face.src = faceWin.src;
    window.open('highscores/minewin.html','MinesweeperWin','toolbar=0,directories=0,menubar=0,scrollbars=1,resizable=1,width=420,height=500');
   } else {
    document.face.src = facePirate.src;
   }
}
    

// Upon finishing a game call a page to record that the game was played. Helps with the stats, finding errors, etc.
function recordPlay() {
    document.iframeLoader.location.replace(
    'highscores/play.asp?gameTime='+clockCurrent+'&gameFormat='+gameFormat+
    '&numMoves='+numMoves+'&remainingBombs='+(maxNumBombs-bombsFlagged)*(!win)+
    '&referrer='+getCookie("referrer") );
}

//
// Associated w/ opening cells & cell clicking
//

// Make sure the check box always has the focus. makes the space bar work.
function forceFocus() {
      document.checkForm.modeCheck.focus() }


// You're dead.  Open the board of bombs.  Assumes death bomb is already
// displayed (and isExposed is set to true).
function deathShowBombs() {
   for (i=0; i<=maxX; i++) {
      for (j=0; j<=maxY; j++) {
         with (cellArray[arrayIndexOf(i,j)]) {
            if (!isExposed) {
               if ((isBomb) && (!isFlagged)) {
                  document.images[imageIndexOf(i,j)].src =  bombRevealed.src; }
               else {
                  if ((!isBomb) && (isFlagged)) {
                  document.images[imageIndexOf(i,j)].src =  bombMisFlagged.src;
               } } } } } } }


// You've won.  Mark any remaining cells as flags.
function winShowFlags() {
   for (i=0; i<=maxX; i++) {
      for (j=0; j<=maxY; j++) {
         with (cellArray[arrayIndexOf(i,j)]) {
            if ((!isExposed) && (!isFlagged)) {
               isFlagged = true;
               document.images[imageIndexOf(i,j)].src = bombFlagged.src; } } } } }
               
// Open all remaining cells. Returns True if the player has won.
// This does not allow for undo.
function openAll() {
   allOK = true;
   for (i=0; i<=maxX; i++) {
      for (j=0; j<=maxY; j++) {
         with (cellArray[arrayIndexOf(i,j)]) {
            if (!isExposed) {
               if ((isBomb) && (!isFlagged)) {
                  document.images[imageIndexOf(i,j)].src = bombDeath.src; 
                  allOK = false;}
               else if ((!isBomb) && (isFlagged)) {
                  document.images[imageIndexOf(i,j)].src = bombMisFlagged.src; }
               else if (!isBomb) {
                  document.images[imageIndexOf(i,j)].src = cellOpenIm[neighborBombs].src; 
               } } } } } 
   return allOK;}


// Complete the death. Called when hit a bomb or when choose not to undo.    
function openCellDeath(x,y) {
   with (cellArray[arrayIndexOf(x,y)]) {
     document.images[imageIndexOf(x,y)].src =  bombDeath.src;
     document.face.src = faceDead.src;
     isExposed = true;
     dead = true;
     updateNumBombs();
     deathShowBombs(); 
     recordPlay();
   }
}


// Actually opens the cell.  Works for bombs & free cells.  Can handle
// recursive calls (through markMatrixToOpen), death (if bomb), and win.
// (should probably be broken up a bit)
function openCell(x,y) {
   // Normal cell opening processing begins here
   with (cellArray[arrayIndexOf(x,y)]) {
      if (isBomb) {
         // death
         clockStop();
         if (allowDisarm) {
          showDisarm(maxX, maxY);
          disarmX = x;
          disarmY = y;
          // In case the user disarms, turn off any other pending cells marked to be opened
          markedCount = -1;
          for (l=0; l<=maxCells; l++) {
            cellArray[l].isMarked = false; }
         } else {
          openCellDeath(x,y);
         }
      }
      else {
         document.images[imageIndexOf(x,y)].src =  cellOpenIm[neighborBombs].src; 
         isExposed = true;
         isMarked = false;
         ++ cellsOpen;
         if ((neighborBombs == 0) && (!isBomb)) {
            markMatrixToOpen(x,y); } 
         if (cellsOpen+maxNumBombs-1 == maxCells) {
            clockStop();
            winShowFlags();
            winShowWindow();
            recordPlay();
            } } } }
         

// Cells on stack marked to be open.  Called on an as-needed baisis.
// See the markCellToOpen fn below.
function constructMarkedCell() {
   this.x = -1;
   this.y = -1; }


// Although Netscapes JavaScript 1.1 documentation says JavaScript is
// recursive, it doesn't actually maintain a stack of local vars!
// So these functions turned out to be a real pain to rewrite with my
// own stack structures.
// Adds an element to the manual stack. 
function markCellToOpen(x,y) {
   ++markedCount;
   // Lengthen the stack if necessary.
   if (highestStackHeight < markedCount) {
     ++highestStackHeight;
     markedArray[markedCount] = new constructMarkedCell() }
   markedArray[markedCount].x = x;
   markedArray[markedCount].y = y;
   cellArray[arrayIndexOf(x,y)].isMarked = true; }


// When you open a cell w/ 0 neighbors or click on a completely flagged
// cell, open all neighbors (not flagged).  Creates recursive calls through
// markCellToOpen
function markMatrixToOpen(x,y) {
   for (i=x-1; i<=x+1; i++) {
      for (j=y-1; j<=y+1; j++) {
         if (checkBounds(i,j)) {
            with (cellArray[arrayIndexOf(i,j)]) {
               if ((!isExposed) && (!isMarked) && (!isFlagged)) {
                  markCellToOpen(i,j); } } } } } }


// Open all cells (usually one) marked for opening.  See markMatrixToOpen
// to see how multiple cells are marked.
function openAllMarked() {
   while (markedCount >= 0) {
      markedCount--;  // Decrement first, in case a matrix is to be open
      with (markedArray[markedCount+1]) {
         openCell(x,y); } } }

// Returns 1 if a cell is flagged, and 0 otherwise.  Used in determining
// if a cell has complete surrounding cells flagged.  See below
function checkFlagged(x,y) {
   if (checkBounds(x,y)) 
      return (cellArray[arrayIndexOf(x,y)].isFlagged) ? (1) : (0); 
   else
      return 0; }


// Count the # of neighbors flagged.  Called for matrix opening.
function checkFlaggedMatrix(x,y) {
   count = 0;
   for (i=x-1; i<=x+1; i++) {
      for (j=y-1; j<=y+1; j++) {
         if ((i!=x) || (j!=y)) {                  //Don't check center point
         count = count + checkFlagged(i,j); } } }
   return count; }


// Called for first click only.  Starts the clock, and makes sure there is
// no bomb for the first open cell (or matrix).
function firstClick(x,y) {
    if (!useFirstClickUseful) {
      if (cellArray[arrayIndexOf(x,y)].isBomb) {
         placeBombRandomLoc();  // Place first to insure different loc
         removeBomb(x,y); } }
    else {
      var i = 0;        // Make local
      var j = 0;
      // Set each cell of the matrix to open to prevent bomb placement.
      for (i=x-1; i<=x+1; i++) {
         for (j=y-1; j<=y+1; j++) {
            if (checkBounds(i,j)) {
               cellArray[arrayIndexOf(i,j)].isExposed = true; } } }
      // Remove any bombs in the matrix and place elsewhere
      for (i=x-1; i<=x+1; i++) {
         for (j=y-1; j<=y+1; j++) {
            if (checkBounds(i,j)) {
               if (cellArray[arrayIndexOf(i,j)].isBomb) {
                  removeBomb(i,j);
                  placeBombRandomLoc();
                  } } } }
      // Set each cell back to normal.  (Let cellClick take it from here).
      for (i=x-1; i<=x+1; i++) {
         for (j=y-1; j<=y+1; j++) {
            if (checkBounds(i,j)) {
               cellArray[arrayIndexOf(i,j)].isExposed = false; } } } }
  boardToBase64();
  clockStart(); }


// Main click function.  Called whenever a cell is clicked.  Based on mode,
// determines what to do about the click. Handles both left and right.
function cellClick(x,y,e) {
//   alert("Clicked cell " + x + "," + y);  //Useful diagnostic line
//   alert("Button pressed = " + e.button) //Useful diagnostic line
   closeAllMenus();
   if ((!dead) && (!win)) {
      document.face.src = faceSmile.src;
      numMoves++;
      // Count the moves
	  if ((e != 2) && (e.button != 2)) {
	      if (!clockMoving)
	         firstClick(x,y);
	      with (cellArray[arrayIndexOf(x,y)]) {
	         // Is it already open?  If so, we may need to do a matrix (macro) open
	         if (isExposed) {
	            if ((useMacroOpen) && (checkFlaggedMatrix(x,y) == neighborBombs)) { 
	               markMatrixToOpen(x,y);
	               openAllMarked(); } }
	         else {
	            if (!isFlagged) { 
	               markCellToOpen(x,y); 
	               openAllMarked(); } } }
	      if (win) {
	         bombsFlagged = maxNumBombs;
	         updateNumBombs(); }
	  }
	  else {
	     if (x > -1) {
	      with (cellArray[arrayIndexOf(x,y)]) {
	         if (!isExposed) {
	            // There are 3 possibilities: blank, flagged, and question
	            // First deal with flagged going to either blank or question
	            if (isFlagged) {
	               bombsFlagged--;
	               isFlagged = false;
	               if (!useQuestionMarks)
	                  document.images[imageIndexOf(x,y)].src = blankCell.src;
	               else {
	                  isQuestion = true;
	                  document.images[imageIndexOf(x,y)].src = (bombQuestion.src); } }
	            // Now deal w/ question going to blank
	            else {
	               if (isQuestion) {
	                  isQuestion = false;
	                  document.images[imageIndexOf(x,y)].src = blankCell.src; }
	               // Finally, blank going to flagged
	               else {
	                  isFlagged = true;
	                  ++bombsFlagged;
	                  document.images[imageIndexOf(x,y)].src = bombFlagged.src; } }
	         updateNumBombs(); } } }
 	  }
   }
  forceFocus();
}


// If cell is not exposed: Flag (right click). If exposed: Perform a macro open (left click).
// Called whenever the value of the check box is toggled.
// For now only with the space bar, for any touch event in a future version.
function cellTouch() {
  if (pointingAtX > -1) {
    if (cellArray[arrayIndexOf(pointingAtX,pointingAtY)].isExposed) {
    	cellClick(pointingAtX,pointingAtY, 1);
    } else {
      if (!clockMoving) {
      	cellClick(pointingAtX,pointingAtY, 1);
      } else {
    	  cellClick(pointingAtX,pointingAtY, 2);
    	}
  	}
  }
}


// Disable the right click button's menu.
function pressRightClick() { return false; } 
document.oncontextmenu = pressRightClick;


// Special routine to ignore dragging starts.
// Allows the mouse to be in motion when the user clicks.
// Only works in IE because there is no onDrag handler in Mozilla
function ignoreDragging() {
   try {
      window.event.returnValue = false; }
   catch (e) {}
   return false; }


// Show or remove the "Ooh" face when the mouse is clicked.
function showMouseDown(e) {
   if ((! dead) && (! win)) {
      closeAllMenus();
      document.face.src = faceOoh.src; } }


// Great diagnostic tool. Logs info about a cell, called when you press "=".
// Assumes a modern browser. Press Ctr-Shift-J to bring up the console in Chrome
function logCell() {
  if (( window.console != undefined) && (window.console.time != undefined)) {
    console.group("Pointing at cell "+pointingAtX+","+pointingAtY);
    console.dir(cellArray[arrayIndexOf(pointingAtX,pointingAtY)]);
    console.groupEnd();
  }
}

// Check for special keys being pressed.
// Note two versions, for older FF & IE.
//    F2: Restart the game. 
//    "P" or "p": Pause
//    "H" or "h": Hint
document.onkeydown = checkKeyDown; // Uses global onkeypress. 
function checkKeyDown(e) { 
	try {
		if (e.keyCode == 113) { faceClick(); }
		else if ((e.keyCode == 80) || (e.keyCode == 113)) { doPause(); }
		else if ((e.keyCode == 72) || (e.keyCode == 104)) { doHint(e); }
		else if (e.keyCode == 187) { logCell(); }
  }
	catch (e) {
  	try {
  		if (window.event.keyCode == 113) { faceClick(); }
  		else if ((window.event.keyCode == 80) || (window.event.keyCode == 113)) { doPause(); }
  		else if ((window.event.keyCode == 72) || (window.event.keyCode == 104)) { doHint(e); }
  		else if (window.event.keyCode == 187) { logCell(); }
    }
  	catch (e) {}
	}
}



// Pause the game.
// Known issue: Pausing the clock then resuming looses any partial second.
function doPause() {
  // Only proceed if the game is ongoing and isn't already paused
  if ((!dead) && (!win) && clockMoving && (!paused)) {
    // Put up the shround, pause the clock, change the face
    paused = true;
    clockStop();
    with (document.getElementById("divPause").style) {
      left=(document.bordertl.height+5)+"px";
      top=(document.face.height+(document.bordertl.height*2)+26)+"px";
      width=(document.cellIm1_1.width*(maxX+1)+6)+"px";
      height=(document.cellIm1_1.height*(maxY+1)+6)+"px";
      visibility="visible";
    }
    document.face.src = faceWait.src;
  } else {
    doUnpause();
  }
}

// Discrete fn so it can be called by faceClick()
function hidePause() {
    document.getElementById("divPause").style.visibility="hidden";
    paused = false;
}

function doUnpause() {
    if ((!dead) && (!win) && (!clockMoving) && paused) {
      document.face.src = faceSmile.src;
      hidePause();
      clockStart();
    }
}

// Show a hint at the current cell.
function doHint(e) {
  // Only proceed if allowing hints, the game is ongoing, the pointer is at a cell.
  if (allowHints && (!dead) && (!win) && clockMoving && (pointingAtX > -1)) {
      with (cellArray[arrayIndexOf(pointingAtX,pointingAtY)]) {
        // Also the cell must be an unopened, non-flagged, non-anything cell.
        if ((! isExposed) && (! isFlagged) && (! isQuestion) && (! isMarked)) {
          // If there are no neighbors then just open it. Otherwise show the shadow image.
          if (isBomb) {
            document.images[imageIndexOf(pointingAtX, pointingAtY)].src = bombShadow.src; 
          } else if (neighborBombs==0) {
            cellClick(pointingAtX, pointingAtY, e);
          } else {
            document.images[imageIndexOf(pointingAtX, pointingAtY)].src = cellShadowIm[neighborBombs].src; 
          }
          // In either case, increment the hints counter.
          ++hints;
        }
      }
  }

}


// When all bombs are marked, user can open all remaining cells.
function bombCountClick() {
   closeAllMenus();
   if ((!dead) && (!win) && (openRemaining) && ((maxNumBombs-bombsFlagged) == 0)) {
      clockStop();
      numMoves++;
      openRemainingUsed = true;
      if (openAll()) {
         winShowWindow(); 
         updateNumBombs(); }
      else {
         dead = true;
         updateNumBombs();
         document.face.src = faceDead.src; } }
   forceFocus();
   return false; }




//
// Board creation, re-initialization, bomb placement, etc.
//


// Support function for makeBoard.  Adds 1 to the neighborBombs property.
// Does a bounds check and a check for not being a bomb. (no change if 
// either condition fails)
function addNeighbor(x,y) {
   if (checkBounds(x,y)) {
      with (cellArray[arrayIndexOf(x,y)]) {
            ++neighborBombs; } } }


// Called only w/ removal of bomb when 1st click is on a bomb.
function removeNeighbor(x,y) {
   if (checkBounds(x,y)) {
      with (cellArray[arrayIndexOf(x,y)]) {
            neighborBombs--; } } }


// Support function for makeBoard, and also called externally if first 
// click is on a bomb.  Places a bomb at x,y loc and updates neighbor 
// counts.  returns true upon success, failure if bomb is already there 
// or if the square is open. (note: isExposed is set temporarily to true
// during first click to avoid bombs being placed in bomb-free zone.)
function placeBomb(x,y) {
   with (cellArray[arrayIndexOf(x,y)]) {
      if ((! isBomb) && (! isExposed)) {
         isBomb = true;
         for (i=x-1; i<=x+1; i++) {
            for (j=y-1; j<=y+1; j++) {
               addNeighbor(i,j); } } 
         return true;} 
      else
         return false; } }


// Only called when user's 1st click is on a bomb.
// NOTE: This fn caused an "internal error: Stack underflow" for a while,
// and then stopped.  I still can't find the cause, but if I split the
// cellArray reference out into a higher "with" statement, it comes back.
// It seems to work fine now, but be careful!
function removeBomb(x,y) {
   if (cellArray[arrayIndexOf(x,y)].isBomb) {
      for (i=x-1; i<=x+1; i++) {
         for (j=y-1; j<=y+1; j++) {
            removeNeighbor(i,j); } } 
      cellArray[arrayIndexOf(x,y)].isBomb = false;
      return true; } 
   else
      return false; }


// Pixed a random stop w/o a bomb already there and places a bomb there.
// Since it works w/ random locs and tests compliance, this fn is only
// suitable for up to ~50% coverage. (I've limited the program to 33%).
function placeBombRandomLoc() {
   bombPlaced = false;
   while (!bombPlaced) {
      with (Math) {
         i = floor(random() * (maxX+1));
         j = floor(random() * (maxY+1)); }
      bombPlaced = (placeBomb(i,j)) } }


// Does a complete clear of the internal board cell objects.
function clearBoard() {
   for (i=0; i<=maxX; i++) {
      for (j=0; j<=maxY; j++) {
         with (cellArray[arrayIndexOf(i,j)]) {
            isExposed = false;
            isBomb = false;
            isFlagged = false;
            isMarked = false;
            isQuestion = false;
            neighborBombs = 0;  } } } }


// Puts the original image on each image cell.
function clearBoardImages() {
   for (j=0; j<=maxY; j++) {
      for (i=0; i<=maxX; i++) {
         with (cellArray[arrayIndexOf(i,j)]) {
            if (document.images[imageIndexOf(i,j)].src != blankCell.src) {
            	document.images[imageIndexOf(i,j)].src = blankCell.src; } } } } }


// Core fn for creating a board.  Does not reset time or clear images.
function makeBoard() {
   clearBoard();
   bombsFlagged = 0;
   cellsOpen = 0;
   updateNumBombs();
   hints = 0;
   disarmed = 0;
   // Now place the bombs on the board
   bombsToPlace = maxNumBombs;
   while (bombsToPlace != 0) {
      placeBombRandomLoc();
      bombsToPlace--; } }


// Resets clock, makes board, clears images, and prepares for next game.
// First time doesn't do a parent reload.
function faceClick_first() {
   hideDisarm();
   hidePause();
   document.face.src = faceWait.src;
   numMoves = 0;
   closeAllMenus();
   clockStop();
   clockClear();
   makeBoard();
   clearBoardImages(); 
   forceFocus();
   dead = false;
   win = false;
   openRemainingUsed = false;
   allowDisarmUsed = false;
   allowHintsUsed = false;
   document.face.src = faceSmile.src;
   return false;
   }

function faceClick() {
    faceClick_first();
   return false;
   }


// Internal testing fns
function timetestStart() {
	timetestStartDt = new Date(); }

function timetestStop() {
   timetestEndDt = new Date();
   alert('Diagnostic Timer: ' + (timetestEndDt - timetestStartDt) + 'ms'); }






//
// Numerical displays (clock and num bomb) updated here
//


// Set the clock images to the current time.  Called by ticClock
function updateClock() {
     tempClock = clockCurrent;
     if (tempClock == -1) { tempClock = 0; }
     digit = tempClock % 10;
     document.time1s.src = timeDigits[digit].src;
     digit = Math.floor(tempClock / 10 % 10);
     document.time10s.src = timeDigits[digit].src;
     digit = Math.floor(tempClock / 100 % 10);
     document.time100s.src = timeDigits[digit].src; }


// Updates the display w/ the current number of bombs left.
function updateNumBombs() {
   if ((!dead) && (!win) && (openRemaining) && ((maxNumBombs-bombsFlagged) == 0)) {
      document.bomb1s.src = movesDigits0.src;
      document.bomb10s.src = movesDigits0.src;
      document.bomb100s.src = movesDigits0.src; }
   else {
      digit = Math.abs(maxNumBombs-bombsFlagged) % 10;
      document.bomb1s.src = timeDigits[digit].src;
      digit = Math.floor(Math.abs(maxNumBombs-bombsFlagged) / 10 % 10);
      document.bomb10s.src = timeDigits[digit].src;
      digit = Math.floor(Math.abs(maxNumBombs-bombsFlagged) / 100 % 10);
      document.bomb100s.src = timeDigits[digit].src;
      if (maxNumBombs < bombsFlagged)
         document.bomb100s.src = timeNeg.src; } }




//
// TIME functions begin here...
//

// Clock tic.  Called once, then it repeats every 1 second.
function ticClock() {
   if (!killLastClock) {
      if (clockMoving) {
         ++ clockCurrent; }
      if ((clockMoving) && (clockCurrent < 1000)) // Max out display at 999
         updateClock(); 
      clockActive = clockMoving;
      if (clockActive)  {              // Always do the recursive call last
         id = setTimeout("ticClock()",1000) } }
   killLastClock = false; }


// Stops the clock
//   SPECIAL NOTE: This function doesn't actually stop the clock: it
//   directs the ticClock fn to stop ticking upon its next recusrive call.
function clockStop() {
   clockMoving = false; }


// Stop and clear the clock.  See specal note in clockStop above.   
function clockClear() {
   // If we're currently moving, we need to first stop it
   if ((!clockMoving) && (clockCurrent != 0)) {
      clockCurrent = 0;
      updateClock(); }
   clockCurrent = -1;
   clockMoving = false; }


// Starts the clock.  Able to start a clear clock or restart a paused
// clock (a feature I'm not using here).
function clockStart() {
   // Stop the clock (sets a temp variable for later interigation)
   clockWasActive = clockActive;
   clockMoving = true;
   ticClock();
   // harder part: We're still running.  Tells ticClock to kill old clock.
   if (clockWasActive) {
      killLastClock = true;  } }
      

// Since it takes so long to close, make a face...
function gameClose() {
   document.face.src = faceWait.src; }






//
// DISARM (aka undo) functions begin here...
//

function showDisarm(maxX, maxY) {
   with (document.getElementById("divDisarm").style) {
     left=(document.bordertl.height+5)+"px";
     top=(document.face.height+(document.bordertl.height*2)+26)+"px";
     width=(document.cellIm1_1.width*(maxX+1)+6)+"px";
     height=(document.cellIm1_1.height*(maxY+1)+6)+"px";
     visibility="visible";
     fuseRemaining = 30;
     fuseBurning = true;
     ticFuse();
     document.face.src = faceOoh.src;
   }
}

function hideDisarm() {
   document.getElementById("divDisarm").style.visibility="hidden";
   document.face.src = faceSmile.src;
}

// Bomb fuse tic.  Called once, then it repeats every 100 ms.
// (Using 100ms in case the user dismisses and then quickly hits another bomb)
function ticFuse() {
  if (fuseBurning) {
     --fuseRemaining;
     if (fuseRemaining<=0) {
        if (! clockMoving) {    // Just in case it was on the last tic when disarmed
          acceptFate();
        }
     } else {
        document.getElementById("detonateCountdown").innerHTML=Math.floor(fuseRemaining/10)+1;
        idFuse = setTimeout("ticFuse()",100);
     }
  }
}

// Stops the fuse (either undoing the last move or accepting the bomb fate)
//   SPECIAL NOTE: This function doesn't actually stop the fuse: it
//   directs the ticFuse fn to stop ticking upon its next recusrive call.
function fuseStop() {
   hideDisarm();
   fuseBurning = false;
}

function acceptFate() {
  fuseStop();
  openCellDeath(disarmX,disarmY);
}

function disarmMine() {
  fuseStop();
  ++disarmed;
  ++bombsFlagged;
  updateNumBombs();
  with (cellArray[arrayIndexOf(disarmX,disarmY)]) {
    isFlagged = true;
    isDisarmed = true;
    isExposed = true;
  }
  document.images[imageIndexOf(disarmX,disarmY)].src = bombDisarmed.src;
  clockStart();
}


// Zooming
// Won't work with all browsers but works with most modern browsers.
// Zoom goes to double size, with a 3 sizes in between (5 sizes total).
// 4th Root of 2 (1.1892) is a great multiplier, it gives a smooth 4-step transition to double size.

zoomLevel = 0;

function zoomPower() {
  return Math.pow(2,zoomLevel/4); }
  
// Called by zoomIn() and zoomOut(). Handles browser differences
function zoomDoTransform() {
  if (document.body.style.transform != undefined) {
    // For modern browsers (CSS3 transform property)
    document.body.style.transform = "scale("+zoomPower()+")";
    document.body.style.transformOrigin = "0 0";
  } else if (document.body.style.zoom != undefined) {
    // Older browsers that don't support transforms yet, but support "zoom" property
    document.body.style.zoom=zoomPower();
  }
  window.resizeTo(calcWidth(maxX), calcHeight(maxY));
}

function zoomIn() {
  if (zoomLevel < 4) {
    zoomLevel++;
    zoomDoTransform();
  }
}

function zoomOut() {
  if (zoomLevel > 0) {
    zoomLevel--;
    zoomDoTransform();
  }
}



//
// MENU functions begin here...
//

// Close a menu
function closeMenu(selectedMenu){
   document.getElementById(selectedMenu).style.visibility="hidden"; }


// Show a menu
function openMenu(selectedMenu){
   document.getElementById(selectedMenu).style.visibility="visible"; }


// Close any visible menus
function closeAllMenus(){
   closeMenu("divMenuHelp");
   closeMenu("divMenuOpt");
   closeMenu("divMenuGame"); }

// Force the menus to close
function clickInBrowser(){
   if (! lastClickOnMenu) {
     closeMenu("divMenuHelp");
     closeMenu("divMenuOpt");
     closeMenu("divMenuGame"); }
   lastClickOnMenu = false;}


// Used in menuGameClick to set the QuestionMarks, MacroOpen and FirstClickUseful
// image check marks.
function menuSetOptionChecks(cookieVar, imageLoc) {
  if (cookieVar)
     imageLoc.src = checked.src
     else imageLoc.src = notchecked.src }


// Set the check marks for the appropriate menu.
function menusSetAllOptionChecks(thisMenu) {
   if (thisMenu == "divMenuGame") {
     // Set all 4 game sizes to blanks
     document.imBeginner.src = notchecked.src
     document.imIntermediate.src = notchecked.src
     document.imExpert.src = notchecked.src
     document.imCustom.src = notchecked.src
     // Set the appropriate one to ckecked
     if (gameFormat == "Beginner") 
        document.imBeginner.src = checked.src
     else if (gameFormat == "Intermediate") 
        document.imIntermediate.src = checked.src
     else if (gameFormat == "Expert")
       document.imExpert.src = checked.src
     else
       document.imCustom.src = checked.src }
   else if (thisMenu == "divMenuOpt") {
     // Set the check marks for the Options menu
     menuSetOptionChecks(useQuestionMarks, document.imMarks)
     menuSetOptionChecks(useMacroOpen, document.imUseMacro)
     menuSetOptionChecks(useFirstClickUseful, document.imFirst)
     menuSetOptionChecks(openRemaining, document.imRemaining) 
     menuSetOptionChecks(allowDisarm, document.imDisarm)
     menuSetOptionChecks(allowHints, document.imHints)  } }


// A menu was clicked
function menuClick(thisMenu) {
   // Determine if the menu is visible. Check BEFORE closing.
   visibleTest = (document.getElementById(thisMenu).style.visibility == "visible");
   // Hide any visible menu, including thisMenu
   closeAllMenus();
   // Toggle the menu. Note that if it was open, it has already been closed.
   if (! visibleTest) {
      menusSetAllOptionChecks(thisMenu);
      openMenu(thisMenu); }
   // Save state. Used to clear menus by clicking anywhere on browser.
   lastClickOnMenu = true;
   return false; }
   

// When a top-level menu is pointed at and another menu it open, close the 
// current menu and open the new menu. This mimics the typical Windows menu 
// behavior.
function menuMouseOver(currentMenu) {
   visibleTestGeneral = ((document.getElementById("divMenuGame").style.visibility == "visible") || (document.getElementById("divMenuOpt").style.visibility == "visible") || (document.getElementById("divMenuHelp").style.visibility == "visible"));
   visibleTestSpecific = (document.getElementById(currentMenu).style.visibility == "visible") ;
   if ((visibleTestGeneral) && (! visibleTestSpecific)) {
      menuClick(currentMenu); }
   return false; }


// Called whenever an item in a menu is called.
function menuItemClick(thisMsg)
{
  // So they selected something... cycle through the options and execute.
  // Game menu...
  if (thisMsg == "Exit")
     window.close()
  else if (thisMsg == "New")
     faceClick()
  else if (thisMsg == "Pause")
    doPause()
  else if ((thisMsg == "Beginner") || (thisMsg == "Intermediate") || (thisMsg == "Expert")) {
     setCookie("gameFormat",thisMsg);
     window.location.reload(); }
  else if (thisMsg == "Custom") {
     setCookie("gameFormat","gameFormat");
     setCookie("maxX",maxX);
     setCookie("maxY",maxY);
     setCookie("maxNumBombs",maxNumBombs);
     menuBarWindow = window.open ('minecustom.html','MinesweeperCustom','toolbar=0,directories=0,menubar=0,scrollbars=1,resizable=0,width=320,height=270,dependent=0,alwaysRaised=1'); 
     window.close(); }
  else if (thisMsg == "Personal") {
     menuBarWindow = window.open ('highscores/minepersonal.html','MinesweeperRecords','toolbar=0,directories=0,menubar=0,scrollbars=1,resizable=0,width=400,height=410,dependent=1,alwaysRaised=1'); }
  else if (thisMsg == "World") {
     menuBarWindow = window.open ('highscores/mineworld.asp','MinesweeperRecords','toolbar=0,directories=0,menubar=0,scrollbars=1,resizable=0,width=400,height=470,dependent=1,alwaysRaised=1'); }

  // Options menu
  else if (thisMsg == "Marks") {
     useQuestionMarks = ! useQuestionMarks;
     setCookie("useQuestionMarks",useQuestionMarks); }
  else if (thisMsg == "Area") {
     useMacroOpen = ! useMacroOpen;
     setCookie("useMacroOpen",useMacroOpen); }
  else if (thisMsg == "First") {
     useFirstClickUseful = ! useFirstClickUseful;
     setCookie("useFirstClickUseful",useFirstClickUseful); }
  else if (thisMsg == "Remaining") {
     openRemaining = ! openRemaining;
     updateNumBombs();
     setCookie("openRemaining",openRemaining); }
  else if (thisMsg == "Disarm") {
     allowDisarm = ! allowDisarm;
     setCookie("allowDisarm",allowDisarm); }
  else if (thisMsg == "Hints") {
     allowHints = ! allowHints;
     setCookie("allowHints",allowHints); }

  // Help menu
  else if (thisMsg == "About") {
     menuBarWindow = window.open ('help/mineabout.html','HelpSub','toolbar=0,directories=0,menubar=0,scrollbars=1,resizable=0,width=400,height=410,dependent=1,alwaysRaised=1'); }
  else if (thisMsg == "Instructions") {
     menuBarWindow = window.open ('help/minehelpinstructions.html','HelpSub','toolbar=0,directories=0,menubar=0,scrollbars=1,resizable=0,width=400,height=410,dependent=1,alwaysRaised=1'); }
  else if (thisMsg == "Technical") {
     menuBarWindow = window.open ('help/minetechnicalnotes.html','HelpSub','toolbar=0,directories=0,menubar=0,scrollbars=1,resizable=0,width=500,height=410,dependent=1,alwaysRaised=1'); }
  else if (thisMsg == "Source") {
     menuBarWindow = window.open ('help/minefilesandsource.html','HelpSub','toolbar=0,directories=0,menubar=0,scrollbars=1,resizable=0,width=400,height=410,dependent=1,alwaysRaised=1'); }
  else if (thisMsg == "Links") {
     menuBarWindow = window.open ('help/minelinks.html','MinesweeperLinks','toolbar=0,directories=0,menubar=0,scrollbars=1,resizable=0,width=550,height=410,dependent=1,alwaysRaised=1'); }

  // Since we clicked, close the menu.
  closeAllMenus();
  // Always return a false to prevent the executing of the default href.
  //  (this is a neat trick - we've already handled the event, so we bypass the default href link)
  return false; }

// -->
</script>



<!-- Menubar -->
<table width="150" border="0" cellspacing="0" cellpadding="0"  class="menu_margin">
<tr>
<td class="menu_title">&nbsp;</td>
<td width="43" class="menu_title"><a onclick="return menuClick('divMenuGame')" onmouseover="return menuMouseOver('divMenuGame')">Game</a></td>
<td width="55" class="menu_title"><a onclick="return menuClick('divMenuOpt')"  onmouseover="return menuMouseOver('divMenuOpt')" >Options</a></td>
<td width="50" class="menu_title"><a onclick="return menuClick('divMenuHelp')" onmouseover="return menuMouseOver('divMenuHelp')">Help</a></td>
</tr>
</table>



<!-- Special check box - retains focus no matter what.
     Note it is located off the screen to the left by 200 pixels.  It looks ugly otherwise. -->
<div class="focus_box">
<form name="checkForm" action="http://www.chezpoor.com/minesweeper/ignore"><input type="checkbox" onclick="cellTouch()" name="modeCheck" /></form>
<iframe width="0px" height="0px" name="iframeLoader" id="iframeLoader"></iframe>
</div>


<!-- Create the board itself
     This is done in JavaScript so the board can be dynamically sized-->


<script type="text/javascript">
<!-- 
   // Create a distinct DIV section for the board, and hide it until it is ready.
   // This is important for slower machines, since the onclick events are
   // available as soon as they are created, even if the board isn't fully built.
   document.writeln('<div id="divBoard" style="visibility:hidden;">');

   // By putting the grid into a table cell, nowrap can be used. Good for Opera.
   document.writeln('<table border="0"><tr><td nowrap="nowrap">');

   // Build the top line
   document.write('<img src="images/bordertl.gif" height="10" width="10" alt="" name="bordertl" />');
   for (j=0; j<=maxX; j++) {
      document.write('<img src="images/bordertb.gif" height="10" width="16" alt="" />'); }
   document.writeln('<img src="images/bordertr.gif" height="10" width="10" alt="" /><br />');

   // Build the top display (# bombs, face, clock)
   document.write('<img src="images/borderlr.gif" height="26" width="10" alt="" />');
   document.write('<a onclick="return bombCountClick()"><img src="images/time0.gif" border="0" name="bomb100s" width="13" height="23" alt="" /><IMG SRC="images/time0.gif" border="0" name="bomb10s" width="13" height="23" alt="" /><img src="images/time0.gif" border="0" name="bomb1s" width="13" height="23" alt="" /></a>');
   document.write('<a onclick="return faceClick()"><img src="images/faceclock.gif" name="face" hspace="'+smileMargin+'" border="0" width="26" height="26" alt="" /></a>');
   document.write('<img src="images/time0.gif" border="0" name="time100s" width="13" height="23" alt="" /><img src="images/time0.gif" border="0" name="time10s" width="13" height="23" alt="" /><img src="images/time0.gif" border="0" name="time1s" width="13" height="23" alt="" />');
   document.writeln('<img src="images/borderlr.gif" height="26" width="10" alt="" /><br />');

   // Line between title stuff and the board
   document.write('<img src="images/borderjointl.gif" height="10" width="10" alt="" />');
   for (j=0; j<=maxX; j++) {
      document.write('<img src="images/bordertb.gif" height="10" width="16" alt="" />'); }
   document.writeln('<img src="images/borderjointr.gif" height="10" width="10" alt="" /><br />');

   // Build the main grid itself, placing it on-screen.  Note the l/r edge
   // Also, using a temp string to build line before display.  Speeds up display.
   for (i=0; i<=maxY; i++) {
      document.write('<img src="images/borderlr.gif" height="16" width="10" alt="" />');
      for (j=0; j<=maxX; j++) {
         // IE requires onDragStart, Netscape requires onDrag. Click is handled via onmouseup.
         document.write('<a onClick="" onmouseover="cursorHoldLoc('+j+','+i+')" onmouseout="cursorClearLoc('+j+','+i+')" ondragstart="ignoreDragging()" ondrag="ignoreDragging()" onmousedown="showMouseDown(event);" onmouseup="cellClick('+j+','+i+', event)">');
         document.write('<img src="images/blank.gif" name="cellIm'+j+'_'+i+'" border="0" height="16" width="16" alt="" /></a>'); }
      document.writeln('<img src="images/borderlr.gif" border="0" height="16" width="10" alt="" /><br />'); }
   
   // Build the bottom line, including corners
   document.write('<img src="images/borderbl.gif" height="10" width="10" alt="" />');
   for (j=0; j<=maxX; j++) {
      document.write('<img src="images/bordertb.gif" height="10" width="16" alt="" />'); }
   document.writeln('<img src="images/borderbr.gif" height="10" width="10" alt="" /><br />');


	// Move the help menu over a bit if the game isn't wide enough
   if (maxX == 7) {
      document.getElementById("divMenuHelp").style.left=70; }

  // Moved to the end to support resizing within a game. Allows for zooming.
   window.resizeTo(calcWidth(maxX), calcHeight(maxY));
   
	// Final settings - populate the board, focus, make the smile face, and create the menus
   faceClick_first();
   
	//end of nowrap table
    document.writeln('</td></tr></table>');
   
	document.writeln('</div>');

	// Make the board visible
	document.getElementById("divBoard").style.visibility = "visible";
	
//-->
</script>

</body>
</html>
